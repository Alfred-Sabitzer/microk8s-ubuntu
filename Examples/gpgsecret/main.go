package main

import (
    b64 "encoding/base64"
	"encoding/json"
	"net/http"
	"regexp"
	"sync"
    "io"

//   "time"
    "fmt"

	"golang.org/x/exp/slog"
//   "github.com/gorilla/mux"
)

var (
	liststatusRe   = regexp.MustCompile(`^\/status[\/]*$`)
	encryptRe   = regexp.MustCompile(`^\/encrypt[\/]*$`)
	decryptRe   = regexp.MustCompile(`^\/decrypt[\/]*$`)
)

type status struct {
 	NoEncrypt   string `json:"noencrypt"`
 	NoDecrypt   string `json:"nodecrypt"`
 	Version   string `json:"version"`
 	Doku string `json:"doku"`
}

type AutoGenerated struct {
    Response string      `json:"response"`
    Number   string      `json:"number"`
    ID       interface{} `json:"id"`
}

type encrypt struct {
 	Text   string `json:"text"`
}

type decrypt struct {
 	Text   string `json:"text"`
}

type datastore struct {
	m map[string]status
	*sync.RWMutex
}

type statusHandler struct {
	store *datastore
}

func (h *statusHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("content-type", "application/json")
	slog.Info("Statushandler")
	switch {
	case r.Method == http.MethodGet && liststatusRe.MatchString(r.URL.Path):
    	slog.Info("ListStatus ServeHTTP")
		h.ListStatus(w, r)
		return
	case r.Method == http.MethodPost && encryptRe.MatchString(r.URL.Path):
    	slog.Info("Encrypt ServeHTTP")
		h.encrypt(w, r)
		return
	case r.Method == http.MethodPost && decryptRe.MatchString(r.URL.Path):
    	slog.Info("Decrypt ServeHTTP")
		h.decrypt(w, r)
		return
	default:
		notFound(w, r)
		return
	}
}

func (h *statusHandler) ListStatus(w http.ResponseWriter, r *http.Request) {
    // KISS
    JsonBytes, err := json.Marshal(status{NoEncrypt: "1", NoDecrypt: "5", Version: "1.17.12", Doku: "https://gitlab.com/Alfred-Sabitzer/microk8s-ubuntu/-/tree/master/gpgsecret?ref_type=heads"})
	if err != nil {
        slog.Error(err.Error())
		internalServerError(w, r)
		return
	}
    slog.Info("List OK")
	w.WriteHeader(http.StatusOK)
	w.Write(JsonBytes)
}

func (h *statusHandler) encrypt(w http.ResponseWriter, r *http.Request) {
    // KISS
/*
    var t = new(encrypt)

 //   bodyBytes, err := io.ReadAll(r.Body)
 //   bodyString := string(bodyBytes)
 //   slog.Info("Encrypt Body:"+bodyString)
 	err := json.NewDecoder(r.Body).Decode(t)
 	if err != nil {
 		fmt.Println("err:", err)
        slog.Error("Decode-Error: ", slog.Any("Encrpyt-Error:", err))
        internalServerError(w, r)
        return
 	}
 */

    var e encrypt
    err := json.NewDecoder(r.Body).Decode(&e)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    fmt.Println(e.Text)
    slog.Info("Encrypt: ",slog.Any("Input :", &e))
    // Output: John fmt.Println(person.Age)
    // Output: 30

/*

        var req = new(encrypt)
        err := json.NewDecoder(r.Body).Decode(&req)
        if err != nil {
                http.Error(w, err.Error(), 400)
                return
        }
        // process with the request parameters
 		fmt.Println("Body:", r.Body)
 		fmt.Println("req:", req.Text)

 */

/*     slog.Info("Encrypt input: ",slog.Any("Text: ", t.Text))
    sEnc := b64.StdEncoding.EncodeToString([]byte("-----BEGIN PGP MESSAGE-----" +
                                                  "" +
                                                  "hQIMAwuelMryDilUAQ/9FnOI62YF49njmGeKK1KoGLSJH++fRSQyPCsO6HB2ZBKX" +
                                                  "WnkYHGxt8SWeXsr1Vgr8SAW6noCe6gd+UGrauI4IYHytr8AGpbQwiKdRMwuUGfY+" +
                                                  "zMLORAaPZnAfED3mtzMgahkSETCUsUzU8PoVpXAcdYHJkhK7MsvNhxRxA6bVsYy" +
                                                  "JosQjHoHC13WSf89LX1QNlJKMFIjjvnj5z93QEiJOERCI6GOvF+qv3jBeNpdjGhQ" +
                                                  "LDxGNTytQNiG6jzzIsJWUBTgEOuEaPGhSlZ2AXDPWM02MkUwdmB0WP7cvkoDen5t" +
                                                  "+qUPfuBHpkCftNEeQcgpGvR8bsHekKEXHdw9aD75bgJLqyd6tMIZ+WwLYhk8JVht" +
                                                  "CVG+q/coejXJuxPhB0+FzWQcGMutdTbPH3b5//aEfzBjEF5vQq/OZ2myIE7Cx+K3" +
                                                  "txQr1CWadW0HBt1oCPXmSTuuxHLWe7DfokuGKSpes1TUq3dv0YCTyLXC8d5dz8b1" +
                                                  "mcBOsP1ZMVZ9QrPecyMhSHuJce6oLSa3vpLiG+sJRNdll0R1NV2iGg8H/KDQdDj+" +
                                                  "0EBvb/fS/6F9invEWN8Ysn0J2kNB4/r5mekbGil9nd/qOH+0q3PaQoziQR4p9txp" +
                                                  "Ox8/6XM6s9rrQAdPxepibE0V3SO8QazVVPbTqI2yGrtGrTuDmW/v1ThQdtzlnVHS" +
                                                  "VgGYJ11GbRTZCWhDNyGcgxkpE2/a0/m8furlpibC+d3B80oEX0Ou+5NWm3CyXzqU" +
                                                  "E9SzqlSOgz0otniA0K8+Js2FCQQRpsqFoYYnZhB7/yRV8VNK/Z+K" +
                                                  "=Q/Rq" +
                                                  "-----END PGP MESSAGE-----"))
    text := "encrypt{Text: "+sEnc+"}"
    slog.Info("Encrypt :"+text)
    JsonBytes, err := json.Marshal(text)
	if err != nil {
        slog.Error(err.Error())
		internalServerError(w, r)
		return
	} */
    slog.Info("Encrypt OK")
	w.WriteHeader(http.StatusOK)
//	w.Write(JsonBytes)
}

func (h *statusHandler) decrypt(w http.ResponseWriter, r *http.Request) {
    // KISS
    var t decrypt

    bodyBytes, err := io.ReadAll(r.Body)
    bodyString := string(bodyBytes)
    slog.Info("Decrypt Body:"+bodyString)

    if err := json.NewDecoder(r.Body).Decode(&t); err != nil {
        slog.Error(err.Error())
        internalServerError(w, r)
        return
    }

    slog.Info("Decrypt input:"+t.Text)
    sEnc := b64.StdEncoding.EncodeToString([]byte("verysecrettext"))
    text := "decrypt{Text: "+sEnc+"}"
    slog.Info("Decrypt:"+text)
    JsonBytes, err := json.Marshal(text)
	if err != nil {
        slog.Error(err.Error())
		internalServerError(w, r)
		return
	}
    slog.Info("Decrypt OK")
	w.WriteHeader(http.StatusOK)
	w.Write(JsonBytes)
}

func internalServerError(w http.ResponseWriter, r *http.Request) {
    slog.Error("Internal Server Error")
	w.WriteHeader(http.StatusInternalServerError)
	w.Write([]byte("internal server error"))
}

func notFound(w http.ResponseWriter, r *http.Request) {
    slog.Error("Not Found")
	w.WriteHeader(http.StatusNotFound)
	w.Write([]byte("not found"))
}

func main() {
	mux := http.NewServeMux()
	statusH := &statusHandler{
		store: &datastore{
			m: map[string]status{  // Initial Status Record
				"1": status{NoEncrypt: "1", NoDecrypt: "5", Version: "1.17.12", Doku: "https://gitlab.com/Alfred-Sabitzer/microk8s-ubuntu/-/tree/master/gpgsecret?ref_type=heads"},
			},
			RWMutex: &sync.RWMutex{},
		},
	}
	mux.Handle("/status", statusH)
	mux.Handle("/status/", statusH)
	mux.Handle("/encrypt", statusH)
	mux.Handle("/encrypt/", statusH)
	mux.Handle("/decrypt", statusH)
	mux.Handle("/decrypt/", statusH)
    slog.Info("Starting Server")
	http.ListenAndServe(":80", mux)
    slog.Info("End Service")
}


/*
package main

import (
    b64 "encoding/base64"
    "fmt"
)

func main() {

    data := "abc123!?$*&()'-=@~"

    sEnc := b64.StdEncoding.EncodeToString([]byte(data))
    fmt.Println(sEnc)

    sDec, _ := b64.StdEncoding.DecodeString(sEnc)
    fmt.Println(string(sDec))
    fmt.Println()

    uEnc := b64.URLEncoding.EncodeToString([]byte(data))
    fmt.Println(uEnc)
    uDec, _ := b64.URLEncoding.DecodeString(uEnc)
    fmt.Println(string(uDec))
}
 */
